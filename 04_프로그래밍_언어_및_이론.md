
# 🧾 04_프로그래밍_언어_및_이론

프로그래밍 언어 및 컴퓨터 이론 파트는 자바(Java)를 중심으로 변수의 타입, 컴파일 방식, 객체지향 개념 등을 설명할 수 있는 능력을 평가합니다. 명확한 개념 정의와 함께 코드 레벨 이해가 중요합니다.

---
## 1. 변수의 타입 지정이 가지는 의미는 무엇이며, 정적 타입과 동적 타입 언어의 차이는 무엇인가요?

### 🔹 변수 타입 지정이란?

타입 지정은 변수에 저장할 수 있는 **데이터의 종류를 명시**하는 것으로, 컴파일러나 인터프리터가 타입 불일치를 사전에 검출할 수 있게 해줍니다. 예를 들어 `int x = "hello";`와 같은 문법 오류를 사전 차단할 수 있습니다.

### 🔹 정적 타입 언어 (Static Typing)

- **타입이 컴파일 타임에 결정됨**
- 변수 선언 시 타입을 명시해야 하며, 변경 불가
- **성능이 우수**하고, **오류를 조기에 발견**할 수 있음
- 대표 언어: Java, C, C++, Go

### 🔹 동적 타입 언어 (Dynamic Typing)

- **타입이 런타임에 결정됨**
- 변수 선언 시 타입 선언이 필요 없음
- 개발 속도는 빠르지만, **런타임 오류 가능성**이 있음
- 대표 언어: Python, JavaScript, Ruby

### 🔸 차이점 요약:

| 구분 | 정적 타입 언어 | 동적 타입 언어 |
| --- | --- | --- |
| 타입 결정 시점 | 컴파일 시점 | 런타임 |
| 안정성 | 높음 | 낮음 |
| 유연성 | 낮음 | 높음 |
| 개발 속도 | 느릴 수 있음 | 빠름 |
| 예시 언어 | Java, C | Python, JS |

---

## 2. 컴파일러와 인터프리터의 차이를 설명해 주세요.

### 🔹 컴파일러(Compiler)

- 전체 소스코드를 **한 번에 번역**하여 목적 코드 또는 중간 코드(예: Java의 bytecode)로 생성
- 이후 실행 파일을 독립적으로 실행
- **성능이 빠르고**, 오류를 컴파일 타임에 확인 가능
- 예: C, C++, Java (JVM 기반)

### 🔹 인터프리터(Interpreter)

- 소스코드를 **한 줄씩 읽고 바로 실행**
- 번역과 실행이 동시에 이뤄짐
- 개발 속도는 빠르지만, 실행 속도는 느리고 **런타임 오류** 발생 가능
- 예: Python, JavaScript, Ruby

### 🔸 차이점 요약:

| 항목 | 컴파일러 | 인터프리터 |
| --- | --- | --- |
| 실행 방식 | 전체 번역 후 실행 | 한 줄씩 실행 |
| 오류 발견 | 컴파일 시점 | 실행 시점 |
| 성능 | 빠름 | 느림 |
| 예시 | Java, C | Python, JS |

---

## 3. 시간복잡도와 공간복잡도의 정의와 분석 방법

### 🔹 시간복잡도(Time Complexity)

- 입력 크기 nnn에 따라 **실행 시간이 어떻게 증가하는지**를 나타냄
- 알고리즘의 성능을 분석할 때 가장 기본이 되는 척도

### 🔹 공간복잡도(Space Complexity)

- 알고리즘 실행 중 **필요한 메모리의 양**을 분석
- 메모리 제한이 있는 환경이나 대용량 데이터 처리 시 중요

### 🔸 주요 표기법: 빅오(Big-O) 표기법

| 표기 | 의미 |
| --- | --- |
| O(1) | 상수 시간 |
| O(n) | 선형 시간 |
| O(log n) | 로그 시간 |
| O(n²) | 이중 루프 |

### 🔹 분석 방법

- 반복문은 루프 횟수 기준으로, 재귀는 호출 깊이 기준으로 계산
- 공간복잡도는 추가 배열, 재귀 스택 사용 등을 고려

---

## 4. 디자인 패턴 중 하나를 설명해 주세요. (예: 싱글턴 패턴)

### 🔹 싱글턴 패턴(Singleton Pattern)이란?

- **하나의 클래스 인스턴스만 존재하도록 제한**하고, 어디서든 그 인스턴스를 참조할 수 있게 하는 디자인 패턴입니다.

### 🔹 사용 목적

- 자원 낭비 방지 (예: DB 연결 객체, 설정 객체, Logger 등)
- **공통 상태를 전역적으로 공유**해야 할 때 유용

### 🔹 구현 예시

```java
java
복사편집
public class ConfigManager {
    private static ConfigManager instance = new ConfigManager();
    private ConfigManager() {}
    public static ConfigManager getInstance() {
        return instance;
    }
}

```

### 🔹 장단점

- ✅ 장점: 자원 절약, 상태 일관성 보장
- ⚠️ 단점: 테스트 어려움, 멀티스레드 환경에서 동기화 이슈

---

## 5. 자바에서 다중 상속이 불가능한 이유와 이를 해결하는 방법

### 🔹 다중 상속 문제점

- 여러 부모 클래스에 동일한 메서드가 정의되었을 경우, 어떤 메서드를 상속할지 **모호성(Diamond Problem)** 발생

### 🔹 Java의 해결 방식

- 클래스는 단일 상속만 허용
- 대신 **인터페이스를 다중 구현**할 수 있게 함

### 🔹 인터페이스 다중 구현 예시

```java
java
복사편집
interface A { void draw(); }
interface B { void paint(); }

class C implements A, B {
    public void draw() { ... }
    public void paint() { ... }
}

```

---

## 6. 객체(Object)와 클래스(Class)의 차이점

| 구분 | 클래스(Class) | 객체(Object) |
| --- | --- | --- |
| 정의 | 설계도, 틀 | 설계도로부터 생성된 실체 |
| 상태 | 없음 | 속성과 동작 보유 |
| 메모리 할당 | 안 됨 | 됨 |

### 예시

```java
java
복사편집
class Car { String model; void drive() {} }
Car myCar = new Car(); // myCar는 객체

```

---

## 7. 클래스와 인터페이스의 차이점과 각각의 사용 시점

### 🔹 클래스(Class)

- *상태(필드)와 동작(메서드)**을 함께 정의
- 상속을 통해 기능을 확장 가능

### 🔹 인터페이스(Interface)

- 클래스가 구현해야 하는 **기능의 명세(계약)**을 정의
- 다중 구현이 가능하여 **유연성과 확장성** 확보

| 항목 | 클래스 | 인터페이스 |
| --- | --- | --- |
| 목적 | 구현 | 규약 |
| 구성 | 필드, 메서드, 생성자 | 상수, 추상/디폴트 메서드 |
| 상속 | 단일 상속 | 다중 구현 가능 |

### 🔸 사용 시점

- **클래스**: 공통 기능 구현 시
- **인터페이스**: 여러 객체 간 공통 기능 규약 정의 시

---

## 8. 오버라이딩(Overriding)과 오버로딩(Overloading)의 차이

### 🔹 오버로딩(Overloading)

- **같은 메서드 이름, 다른 매개변수**
- 컴파일 타임 결정

```java
java
복사편집
void print(String s) {}
void print(int n) {}

```

### 🔹 오버라이딩(Overriding)

- **상속받은 메서드를 재정의**
- 런타임 다형성 구현

```java
java
복사편집
class Animal { void sound() {} }
class Dog extends Animal {
    void sound() { System.out.println("bark"); }
}

```

| 항목 | 오버로딩 | 오버라이딩 |
| --- | --- | --- |
| 관계 | 동일 클래스 | 상속 관계 |
| 인자 | 다름 | 같음 |
| 리턴 타입 | 상관 없음 | 같거나 하위 타입 |

---

## 9. 객체지향 언어의 특징과 절차지향 언어와의 차이

### 🔹 객체지향(OOP)의 4대 특성

1. **추상화**: 핵심만 표현
2. **캡슐화**: 내부 구현 은닉
3. **상속**: 기존 코드 재사용
4. **다형성**: 동일 인터페이스, 다양한 구현

### 🔹 절차지향 vs 객체지향

| 항목 | 절차지향 | 객체지향 |
| --- | --- | --- |
| 구조 | 함수 중심 | 객체 중심 |
| 재사용성 | 낮음 | 높음 |
| 유지보수 | 어렵다 | 용이함 |

---

## 10. 추상 클래스와 인터페이스의 차이

### 🔹 추상 클래스(Abstract Class)

- 일부 기능 구현 가능
- **공통 기능 제공 + 확장성**

### 🔹 인터페이스(Interface)

- 기능 명세만 정의
- 다중 구현 가능

| 항목 | 추상 클래스 | 인터페이스 |
| --- | --- | --- |
| 메서드 | 추상 + 일반 메서드 | 추상, default, static |
| 다중 상속 | 불가 | 가능 |
| 목적 | 기능 일부 제공 | 기능 명세 정의 |

---

## 11. 다형성이란? 자바에서의 구현 방법

### 🔹 다형성(Polymorphism)

- 하나의 인터페이스로 **여러 구현체를 동일하게 다룰 수 있는 능력**

### 🔹 Java에서의 구현

1. **상속 + 오버라이딩**
2. **인터페이스 구현**
3. **업캐스팅 + 동적 바인딩**

```java
java
복사편집
class Animal { void speak() {} }
class Cat extends Animal { void speak() { System.out.println("Meow"); } }

Animal a = new Cat();
a.speak(); // Meow

```
---

면접에서는 이론의 정확한 정의보다도 **실제 사용 맥락과 코드 예시를 설명할 수 있는 능력**이 중요합니다.
